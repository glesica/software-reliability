<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>/topics/functional-testing [software reliability]</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>
  div.sourceCode, pre.output {
      border: 1px solid gainsboro;
      box-shadow: 3px 3px 10px gainsboro;
      display: block;
      font-size: 0.9rem;
      padding: 1.0rem;
  }

  figure {
      text-align: center;
  }

  figcaption {
      font-size: 0.8rem;
      font-style: italic;
      text-align: center;
  }

  #before {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid black;
  }

  #after {
      display: flex;
      justify-content: space-between;
      border-top: 1px solid black;
  }
  </style>
</head>
<body>
<div id="banner">
    <img src="media/header.jpg" alt="Course Header">
</div>
<div id="before">
    Software Reliability and Testing
    <div id="before-links">
        <a href="../.." title="Course Home">Home</a> |
        <a href="https://github.com/glesica/software-reliability" title="Course GitHub Page">GitHub</a>
    </div>
</div>
<h1 id="functional-testing">Functional Testing</h1>
<p>When we sit down to a build a piece of software, how do we know what to build? In most cases, we know what to build because we’ve gathered a set of requirements, characteristics our software must have in order to be considered “complete” and “correct”. The process of gathering requirements can be as detailed as we want to make it.</p>
<p>Sometimes, if we’re building software for ourselves, we may skip this step since the requirements are already in our heads (or we might quickly jot them down so we don’t forget).</p>
<p>In other cases it may take weeks or even months to identify what our software must do, particularly when we are unfamiliar with the problem to be solved (the domain). For example, I worked for a company that makes software for accountants. I know very little about accounting, so when I was asked to build some feature I had to ask a lot of questions first to make sure that what I ended up with was useful to accountants.</p>
<h2 id="requirements">Requirements</h2>
<p>There are two kinds of requirements, functional and non-functional. They are described below. We will, however, focus on function requirements for now.</p>
<h3 id="functional-requirements">Functional Requirements</h3>
<p>Functional requirements deal with what the software in question does. You can think of a functional requirement as a “feature” without much loss of accuracy.</p>
<p>Programming assignments in your CS course mostly specify functional requirements. For example, your program must print “Hello, World” when run. Or, “given a set of numbers, your program must print the numbers from the set that are prime”. In a larger application, a functional requirement would probably include background information and additional detail, but the idea is the same: functional requirements are concerned with what the program does.</p>
<h3 id="non-functional-requirements">Non-functional Requirements</h3>
<p>We will discuss non-functional requirements more later in the semester, but for now you can think of these as requirements that deal with how the program does what it does.</p>
<p>For example, performance is generally a non-functional requirement. In the second example above, your assignment might specify that your program must be able to identify all the prime numbers in a set of 100 values within 10ms, or that the algorithm must have O(n) performance for larger input sets.</p>
<p>These are non-functional requirements because they do not affect the answers or output produced by the program. However, this doesn’t make them less important, non-functional requirements can be deal breakers in many cases (for instance, performance is incredibly important for games).</p>
<h2 id="functional-testing-1">Functional Testing</h2>
<p>Functional testing is probably the most obvious form of testing (doing it well requires some subtlety, though). In fact, every single one of us probably invented it independently the day we wrote our first program.</p>
<p>Think of the first program you wrote, what did you do after you wrote it? You ran it, of course! And you probably verified that the output was what you expected (likely “Hello, world”). That is functional testing in a nutshell.</p>
<p>A functional test attempts to verify one or more functional requirements of the software in question. For example, a functional test for a “Hello, world” program simply verifies that, when run, the software prints the string “Hello, world”.</p>
<p>Historically, functional testing was largely a manual process. Armies of software testers would interact with the application under test, completing predetermined sets of tasks and reporting bugs as they were encountered. While manual functional testing is still used (and is likely to continue to be necessary), automated functional testing has replaced it for simpler tasks. In some cases, manual testing has also been moved to the users since the internet enables frequent bug fixes.</p>
<h3 id="manual-functional-testing">Manual Functional Testing</h3>
<p>Manual functional testing requires that the tester be provided with unambiguous instructions that describe the task to be completed and the expected result, this is known as a test specification or “spec” for short.</p>
<p>One benefit of manual testing is that these test specifications can often assume a certain baseline level of knowledge, although doing so isn’t always wise. For example, a tester working on a word processor might be assumed to know what to do when told to “open” a document. However, this can become problematic. Should the tester use a keyboard shortcut, the File menu, or even a toolbar button? What about just double-clicking on the file to be opened? In some cases it might not matter, but in others the tester’s choice could allow a bug to slip through.</p>
<p>A reasonable test specification for the <code>ls</code> command is shown below.</p>
<ol type="1">
<li>Open a terminal in a directory that contains one sub-directory, one symlink to that sub-directory, and one regular file</li>
<li>Run <code>ls</code></li>
<li>Observe the list of files printed on the screen and verify that it contains each of the three items described above</li>
</ol>
<h3 id="automated-functional-testing">Automated Functional Testing</h3>
<p>Many functional tests can be automated to improve consistency and speed and reduce costs. Unfortunately, automating functional tests can be somewhat complex because the tests must be “driven” by a piece of software that controls the computer in the same way that a human would. Furthermore, different drivers are required for different interface types.</p>
<p>We will discuss two drivers. The first, called <a href="https://github.com/commander-cli/commander">Commander</a> is used to automate command line applications. The second, called <a href="https://pptr.dev">Puppeteer</a> is widely used to test web applications using the Chrome or Chromium web browsers.</p>
<h4 id="commander">Commander</h4>
<p>There are a number of ways to test command line applications. The simplest way is just to capture the output by redirecting it to a file and compare that file to a known “good” output. This style of testing is commonly known as “gold file” testing, the known good output is the “gold” file.</p>
<p>This style of testing has drawbacks, though. Gold file tests can be brittle; small changes to the program can still cause an entire gold file test to fail. Additionally, the gold files themselves can be cumbersome to create and update.</p>
<p>We can also test program output in smaller chunks. We can do this manually, of course, but it’s easier if we use a tool to make it easier.</p>
<p>As an example, we will create a couple tests for a command line utility included by default on most systems using <a href="https://github.com/commander-cli/commander">Commander</a>, a handy tool for testing command line applications. There is a trivial example below.</p>
<pre class="output"><code>tests:
  echo hello world:
    stdout: hello world
    exit-code: 0</code></pre>
<p>We can run this with the following command, assuming the file above is saved as <code>echo_test.yaml</code>:</p>
<pre class="output"><code>commander test echo_test.yaml</code></pre>
<p>Check out the <a href="commander/">example</a> we will use in class, complete with a Docker image.</p>
<h4 id="puppeteer">Puppeteer</h4>
<h2 id="non-functional-testing">Non-functional Testing</h2>
<p>We will discuss various forms of non-functional testing later in the semester. These will include performance testing and various forms of security analysis.</p>
<p>Command Line</p>
<p>Web Browser We can also functionally test web applications. Gold file tests are possible using images or raw HTML, but we can also automate the web browser itself in order to create more advanced tests that interact with and verify properties of individual HTML elements. Puppeteer Examples Puppeteer is a tool for automating a web browser. It is relatively recent and relies on a protocol that is currently only implemented in Google Chrome, but support is planned for all three major web browsers. As its name implies, Puppeteer allows us to interact with a web browser using code that can be assembled into scripts for repeatability. We will use Puppeteer to verify some characteristics of some popular web sites as though we were developers testing them. Puppeteer is distributed as a JavaScript library and it can be installed using NPM. You can find examples that use Puppeteer here: https://github.com/um-software-testing/reddit-puppeteer</p>

<div id="after">
    <a href="#">Back to top</a>
    <div id="after-links">
        <a href="../.." title="Course Home">Home</a> |
        <a href="https://github.com/glesica/software-reliability" title="Course GitHub Page">GitHub</a>
    </div>
</div>
</body>
</html>
